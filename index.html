<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quartett-Karten-Ersteller</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.3.2/uuid.min.js"></script>
    <style>
        body {
            font-family: "Inter", sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f4f8; /* Light blue-gray background */
        }
        /* Container for aspect ratio */
        .card-container {
            width: 100%;
            padding-bottom: 133.33%; /* 3:4 Aspect Ratio (4/3 * 100%) */
            position: relative;
        }
        /* Content inside the aspect ratio container */
        .card-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            border-radius: 0.75rem; /* rounded-xl */
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* shadow-md */
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // Utility function to generate unique IDs
        const generateUniqueId = () => {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        };

        // Component for a single card preview (front side)
        // Zeigt eine einzelne Karte in der Hauptübersicht und im Editor an.
        // Passt das Layout dynamisch an die Anzahl der Kategorien an.
        const CardPreview = ({ card, categories, onClick, isEditable = true, onImageUpload }) => {
            const fileInputRef = React.useRef(null);

            // Determine image height dynamically based on number of categories
            const imageHeightClass = categories.length <= 3 ? 'h-3/5' : 'h-2/5';
            const imageHeightStyle = categories.length <= 3 ? { height: '60%' } : { height: '40%' };

            // Handle click on "Kein Bild" to trigger file input
            const handleNoImageClick = () => {
                if (onImageUpload && fileInputRef.current) {
                    fileInputRef.current.click();
                }
            };

            // Handle file selection for image upload
            const handleFileChange = (e) => {
                const file = e.target.files[0];
                if (file && onImageUpload) {
                    onImageUpload(file);
                }
            };

            return (
                <div
                    className={`card-container ${isEditable ? 'cursor-pointer transform transition-transform hover:scale-105' : ''}`}
                    onClick={isEditable ? () => onClick(card.id) : undefined}
                >
                    <div className="card-content bg-white border border-gray-200 p-2 sm:p-4">
                        {/* Card Title - Larger */}
                        <h3 className="text-lg sm:text-xl font-bold text-center mb-2 truncate">
                            {card.title || 'Neue Karte'}
                        </h3>

                        {/* Card Image - Dynamic Size */}
                        <div
                            className={`w-full flex items-center justify-center bg-gray-100 rounded-md overflow-hidden mb-2 ${imageHeightClass}`}
                            style={imageHeightStyle}
                        >
                            {card.image ? (
                                <img src={card.image} alt={card.title} className="w-full h-full object-cover" />
                            ) : (
                                <div
                                    className={`text-gray-400 text-xs sm:text-sm ${onImageUpload ? 'cursor-pointer hover:text-blue-500' : ''}`}
                                    onClick={onImageUpload ? handleNoImageClick : undefined}
                                >
                                    Kein Bild
                                </div>
                            )}
                            {onImageUpload && (
                                <input
                                    type="file"
                                    ref={fileInputRef}
                                    accept="image/*"
                                    onChange={handleFileChange}
                                    className="hidden"
                                />
                            )}
                        </div>

                        {/* Category Values - Dynamic Layout (single column for prominence) */}
                        <div className="flex flex-col gap-y-1 text-sm sm:text-base flex-grow overflow-y-auto pr-1">
                            {categories.map(category => (
                                <div key={category.id} className="flex justify-between items-center py-0.5 px-1 bg-blue-50 rounded-md">
                                    <span className="font-semibold text-blue-800 truncate">{category.name}:</span>
                                    <span className="text-gray-700 ml-1 truncate">{card.categoryValues[category.id] || '-'}</span>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        // Component for a single card back preview
        // Zeigt eine Vorschau der Kartenrückseite an.
        const CardBackPreview = ({ cardBack }) => {
            let backgroundStyle = {};
            if (cardBack.type === 'color') {
                backgroundStyle = { backgroundColor: cardBack.color };
            } else if (cardBack.type === 'gradient') {
                backgroundStyle = {
                    background: `linear-gradient(to bottom right, ${cardBack.gradientStart}, ${cardBack.gradientEnd})`
                };
            } else if (cardBack.type === 'image' && cardBack.image) {
                backgroundStyle = {
                    backgroundImage: `url(${cardBack.image})`,
                    backgroundSize: 'cover',
                    backgroundPosition: 'center'
                };
            }

            return (
                <div className="card-container">
                    <div
                        className="card-content flex items-center justify-center p-4 text-white text-center font-bold text-xl sm:text-3xl"
                        style={backgroundStyle}
                    >
                        {/* Only show text if type is color, gradient, or text AND cardBack.text is not empty */}
                        {(cardBack.type === 'text' || cardBack.type === 'color' || cardBack.type === 'gradient') && cardBack.text && (
                            <span className="p-2 bg-black bg-opacity-50 rounded-md">{cardBack.text}</span>
                        )}
                    </div>
                </div>
            );
        };

        // Component for game setup (title, categories, card count, back options)
        // Verantwortlich für die Eingabe des Spieltitels, Kategorien und die Kartenanzahl.
        // Verwaltet auch die Optionen für die Kartenrückseite.
        const GameSetup = ({
            gameTitle, setGameTitle,
            categories, setCategories,
            numCards, setNumCards,
            cardBack, setCardBack,
            onCategoriesChange // Callback to update cards when categories change
        }) => {
            const [newCategoryName, setNewCategoryName] = React.useState('');

            // Add a new category
            const handleAddCategory = () => {
                if (newCategoryName.trim()) {
                    const newCategory = { id: generateUniqueId(), name: newCategoryName.trim() };
                    const updatedCategories = [...categories, newCategory];
                    setCategories(updatedCategories);
                    onCategoriesChange(updatedCategories); // Notify App to update card values
                    setNewCategoryName('');
                }
            };

            // Remove an existing category
            const handleRemoveCategory = (idToRemove) => {
                const updatedCategories = categories.filter(cat => cat.id !== idToRemove);
                setCategories(updatedCategories);
                onCategoriesChange(updatedCategories); // Notify App to update card values
            };

            // Handle image upload for card back
            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        setCardBack(prev => ({ ...prev, image: reader.result, type: 'image' }));
                    };
                    reader.readAsDataURL(file);
                }
            };

            return (
                <div className="bg-white p-4 sm:p-6 rounded-xl shadow-md mb-6">
                    <h2 className="text-xl sm:text-2xl font-semibold mb-4 text-gray-800">Spiel-Einstellungen</h2>

                    {/* Game Title */}
                    <div className="mb-4">
                        <label htmlFor="gameTitle" className="block text-sm font-medium text-gray-700 mb-1">
                            Spiel-Titel:
                        </label>
                        <input
                            type="text"
                            id="gameTitle"
                            className="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500"
                            value={gameTitle}
                            onChange={(e) => setGameTitle(e.target.value)}
                            placeholder="Mein Quartett-Spiel"
                        />
                    </div>

                    {/* Categories */}
                    <div className="mb-4">
                        <label className="block text-sm font-medium text-gray-700 mb-1">
                            Kategorien:
                        </label>
                        <div className="flex mb-2">
                            <input
                                type="text"
                                className="flex-grow p-2 border border-gray-300 rounded-l-md focus:ring-blue-500 focus:border-blue-500"
                                value={newCategoryName}
                                onChange={(e) => setNewCategoryName(e.target.value)}
                                placeholder="Neue Kategorie hinzufügen (z.B. 'Tore')"
                            />
                            <button
                                onClick={handleAddCategory}
                                className="px-4 py-2 bg-blue-600 text-white rounded-r-md hover:bg-blue-700 transition-colors"
                            >
                                Hinzufügen
                            </button>
                        </div>
                        <div className="flex flex-wrap gap-2">
                            {categories.map(category => (
                                <span
                                    key={category.id}
                                    className="inline-flex items-center px-3 py-1 bg-blue-100 text-blue-800 text-sm font-medium rounded-full"
                                >
                                    {category.name}
                                    <button
                                        onClick={() => handleRemoveCategory(category.id)}
                                        className="ml-2 text-blue-600 hover:text-blue-800 focus:outline-none"
                                    >
                                        &times;
                                    </button>
                                </span>
                            ))}
                        </div>
                    </div>

                    {/* Number of Cards */}
                    <div className="mb-4">
                        <label htmlFor="numCards" className="block text-sm font-medium text-gray-700 mb-1">
                            Anzahl der Karten:
                        </label>
                        <input
                            type="text" // Changed to text to allow full control over string formatting
                            id="numCards"
                            className="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500"
                            value={numCards.toString()} // Always display the string representation of the number
                            onChange={(e) => {
                                const val = e.target.value;
                                // Allow empty string (for clearing the input) or strings containing only digits
                                if (val === '' || /^\d+$/.test(val)) {
                                    // Parse to integer, default to 0 if empty or invalid after digit check
                                    setNumCards(parseInt(val, 10) || 0);
                                }
                                // If input is not valid (e.g., contains non-digits), do not update state,
                                // so the last valid number remains displayed.
                            }}
                        />
                    </div>

                    {/* Card Back Options */}
                    <div className="mb-4">
                        <label className="block text-sm font-medium text-gray-700 mb-2">
                            Kartenrückseite:
                        </label>
                        <div className="flex flex-wrap gap-4 mb-3">
                            <label className="flex items-center">
                                <input
                                    type="radio"
                                    name="cardBackType"
                                    value="color"
                                    checked={cardBack.type === 'color'}
                                    onChange={() => setCardBack(prev => ({ ...prev, type: 'color' }))}
                                    className="form-radio text-blue-600"
                                />
                                <span className="ml-2 text-gray-700">Einzelfarbe</span>
                            </label>
                            <label className="flex items-center">
                                <input
                                    type="radio"
                                    name="cardBackType"
                                    value="gradient"
                                    checked={cardBack.type === 'gradient'}
                                    onChange={() => setCardBack(prev => ({ ...prev, type: 'gradient' }))}
                                    className="form-radio text-blue-600"
                                />
                                <span className="ml-2 text-gray-700">Farbverlauf</span>
                            </label>
                            <label className="flex items-center">
                                <input
                                    type="radio"
                                    name="cardBackType"
                                    value="image"
                                    checked={cardBack.type === 'image'}
                                    onChange={() => setCardBack(prev => ({ ...prev, type: 'image' }))}
                                    className="form-radio text-blue-600"
                                />
                                <span className="ml-2 text-gray-700">Eigenes Bild</span>
                            </label>
                            <label className="flex items-center">
                                <input
                                    type="radio"
                                    name="cardBackType"
                                    value="text"
                                    checked={cardBack.type === 'text'}
                                    onChange={() => setCardBack(prev => ({ ...prev, type: 'text' }))}
                                    className="form-radio text-blue-600"
                                />
                                <span className="ml-2 text-gray-700">Nur Text</span>
                            </label>
                        </div>

                        {cardBack.type === 'color' && (
                            <div className="mb-3">
                                <label htmlFor="backColor" className="block text-sm font-medium text-gray-700 mb-1">
                                    Farbe wählen:
                                </label>
                                <input
                                    type="color"
                                    id="backColor"
                                    value={cardBack.color}
                                    onChange={(e) => setCardBack(prev => ({ ...prev, color: e.target.value }))}
                                    className="w-full h-10 rounded-md border border-gray-300"
                                />
                            </div>
                        )}

                        {cardBack.type === 'gradient' && (
                            <div className="grid grid-cols-2 gap-4 mb-3">
                                <div>
                                    <label htmlFor="gradientStart" className="block text-sm font-medium text-gray-700 mb-1">
                                        Verlauf Startfarbe:
                                    </label>
                                    <input
                                        type="color"
                                        id="gradientStart"
                                        value={cardBack.gradientStart}
                                        onChange={(e) => setCardBack(prev => ({ ...prev, gradientStart: e.target.value }))}
                                        className="w-full h-10 rounded-md border border-gray-300"
                                    />
                                </div>
                                <div>
                                    <label htmlFor="gradientEnd" className="block text-sm font-medium text-gray-700 mb-1">
                                        Verlauf Endfarbe:
                                    </label>
                                    <input
                                        type="color"
                                        id="gradientEnd"
                                        value={cardBack.gradientEnd}
                                        onChange={(e) => setCardBack(prev => ({ ...prev, gradientEnd: e.target.value }))}
                                        className="w-full h-10 rounded-md border border-gray-300"
                                    />
                                </div>
                            </div>
                        )}

                        {/* Text input for back side, shown for color, gradient, and text-only types */}
                        {(cardBack.type === 'color' || cardBack.type === 'gradient' || cardBack.type === 'text') && (
                            <div className="mb-3">
                                <label htmlFor="backText" className="block text-sm font-medium text-gray-700 mb-1">
                                    Text auf der Rückseite:
                                </label>
                                <input
                                    type="text"
                                    id="backText"
                                    className="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500"
                                    value={cardBack.text}
                                    onChange={(e) => setCardBack(prev => ({ ...prev, text: e.target.value }))}
                                    placeholder="Mein Quartett"
                                />
                            </div>
                        )}

                        {cardBack.type === 'image' && (
                            <div>
                                <label htmlFor="backImageUpload" className="block text-sm font-medium text-gray-700 mb-1">
                                    Bild für Rückseite hochladen:
                                </label>
                                <input
                                    type="file"
                                    id="backImageUpload"
                                    accept="image/*"
                                    onChange={handleImageUpload}
                                    className="block w-full text-sm text-gray-500
                                               file:mr-4 file:py-2 file:px-4
                                               file:rounded-full file:border-0
                                               file:text-sm file:font-semibold
                                               file:bg-blue-50 file:text-blue-700
                                               hover:file:bg-blue-100"
                                />
                                {cardBack.image && (
                                    <div className="mt-2 text-sm text-gray-600">
                                        Bild hochgeladen.
                                        <button
                                            onClick={() => setCardBack(prev => ({ ...prev, image: null, type: 'color', color: '#3b82f6', text: 'Mein Quartett' }))} // Reset to default color back
                                            className="ml-2 text-red-600 hover:text-red-800"
                                        >
                                            Entfernen
                                        </button>
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // Modal for editing a single card
        // Ein Modal, das geöffnet wird, um eine einzelne Karte detailliert zu bearbeiten.
        const CardEditor = ({ card, categories, onSave, onCancel, cardBack }) => {
            const [editedCard, setEditedCard] = React.useState(card);

            React.useEffect(() => {
                // Ensure categoryValues are initialized for new categories
                const newCategoryValues = {};
                categories.forEach(cat => {
                    newCategoryValues[cat.id] = editedCard.categoryValues[cat.id] || '';
                });
                setEditedCard(prev => ({ ...prev, categoryValues: newCategoryValues }));
            }, [categories, card.id]); // Depend on categories and card.id to re-initialize if categories change or a new card is loaded

            // Handle general input changes (e.g., card title)
            const handleChange = (e) => {
                const { name, value } = e.target;
                setEditedCard(prev => ({ ...prev, [name]: value }));
            };

            // Handle changes to category values
            const handleCategoryValueChange = (categoryId, value) => {
                setEditedCard(prev => ({
                    ...prev,
                    categoryValues: {
                        ...prev.categoryValues,
                        [categoryId]: value
                    }
                }));
            };

            // Handle image upload for the card
            const handleImageUpload = (file) => { // Now accepts file directly
                if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        setEditedCard(prev => ({ ...prev, image: reader.result }));
                    };
                    reader.readAsDataURL(file);
                }
            };

            return (
                <div className="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center p-4 z-50">
                    <div className="bg-white p-6 rounded-xl shadow-lg w-full max-w-4xl max-h-[90vh] overflow-y-auto grid grid-cols-1 md:grid-cols-2 gap-6">
                        {/* Card Editing Controls */}
                        <div>
                            <h2 className="text-xl sm:text-2xl font-semibold mb-4 text-gray-800">Karte bearbeiten</h2>

                            {/* Card Title */}
                            <div className="mb-4">
                                <label htmlFor="cardTitle" className="block text-sm font-medium text-gray-700 mb-1">
                                    Karten-Titel:
                                </label>
                                <div className="flex gap-2">
                                    <input
                                        type="text"
                                        id="cardTitle"
                                        name="title"
                                        className="flex-grow p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500"
                                        value={editedCard.title}
                                        onChange={handleChange}
                                        placeholder="Titel der Karte"
                                    />
                                </div>
                            </div>

                            {/* Category Values */}
                            <div className="mb-4">
                                <label className="block text-sm font-medium text-gray-700 mb-2">
                                    Werte pro Kategorie:
                                </label>
                                {categories.length === 0 && (
                                    <p className="text-gray-500 text-sm">Bitte fügen Sie zuerst Kategorien im Spiel-Setup hinzu.</p>
                                )}
                                {categories.map(category => (
                                    <div key={category.id} className="mb-3">
                                        <label htmlFor={`category-${category.id}`} className="block text-sm font-medium text-gray-700 mb-1">
                                            {category.name}:
                                        </label>
                                        <input
                                            type="text"
                                            id={`category-${category.id}`}
                                            className="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500"
                                            value={editedCard.categoryValues[category.id] || ''}
                                            onChange={(e) => handleCategoryValueChange(category.id, e.target.value)}
                                            placeholder={`Wert für ${category.name}`}
                                        />
                                    </div>
                                ))}
                            </div>

                            {/* Card Image */}
                            <div className="mb-4">
                                <label htmlFor="cardImageUpload" className="block text-sm font-medium text-gray-700 mb-1">
                                    Bild hochladen:
                                </label>
                                <input
                                    type="file"
                                    id="cardImageUpload"
                                    accept="image/*"
                                    onChange={(e) => handleImageUpload(e.target.files[0])}
                                    className="block w-full text-sm text-gray-500
                                               file:mr-4 file:py-2 file:px-4
                                               file:rounded-full file:border-0
                                               file:text-sm file:font-semibold
                                               file:bg-blue-50 file:text-blue-700
                                               hover:file:bg-blue-100"
                                />
                                {editedCard.image && (
                                    <div className="mt-2 flex items-center gap-2">
                                        <img src={editedCard.image} alt="Vorschau" className="w-24 h-24 object-cover rounded-md border border-gray-200" />
                                        <button
                                            onClick={() => setEditedCard(prev => ({ ...prev, image: null }))}
                                            className="text-red-600 hover:text-red-800 text-sm"
                                        >
                                            Bild entfernen
                                        </button>
                                    </div>
                                )}
                            </div>

                            {/* Action Buttons */}
                            <div className="flex justify-end gap-3 mt-6">
                                <button
                                    onClick={onCancel}
                                    className="px-5 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-100 transition-colors"
                                >
                                    Abbrechen
                                </button>
                                <button
                                    onClick={() => onSave(editedCard)}
                                    className="px-5 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
                                >
                                    Speichern
                                </button>
                            </div>
                        </div>

                        {/* Live Card Previews */}
                        <div className="flex flex-col gap-6">
                            <div>
                                <h3 className="text-xl font-semibold mb-4 text-gray-800">Vorderseite Vorschau</h3>
                                <CardPreview card={editedCard} categories={categories} isEditable={false} onImageUpload={handleImageUpload} />
                            </div>
                            <div>
                                <h3 className="text-xl font-semibold mb-4 text-gray-800">Rückseite Vorschau</h3>
                                <CardBackPreview cardBack={cardBack} />
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // Component for Export Buttons and Logic
        // Enthält die Schaltflächen zum Exportieren des Spiels als PDF oder ZIP.
        const ExportButtons = ({ gameTitle, cards, categories, cardBack }) => {
            const [isExporting, setIsExporting] = React.useState(false);

            // Determine image height for export dynamically based on number of categories
            const getImageHeightPercentage = (categoriesCount) => {
                return categoriesCount <= 3 ? '60%' : '40%';
            };

            // Function to generate card HTML for rendering (used by html2canvas)
            // Erzeugt den HTML-Inhalt einer Karte für den Export.
            const generateCardHtml = (card, categories) => {
                const imageHeight = getImageHeightPercentage(categories.length);

                const categoryHtml = categories.map(category => `
                    <div class="flex justify-between items-center py-0.5 px-1 bg-blue-50 rounded-md">
                        <span class="font-semibold text-blue-800 text-sm">${category.name}:</span>
                        <span class="text-gray-700 ml-1 text-sm">${card.categoryValues[category.id] || '-'}</span>
                    </div>
                `).join('');

                return `
                    <div class="card-content bg-white border border-gray-200 p-2" style="width: 100%; height: 100%; box-sizing: border-box;">
                        <h3 class="font-bold text-center mb-2" style="font-size: 1.25rem;">${card.title || 'Neue Karte'}</h3>
                        <div class="w-full flex items-center justify-center bg-gray-100 rounded-md overflow-hidden mb-2" style="height: ${imageHeight};">
                            ${card.image ? `<img src="${card.image}" alt="${card.title}" class="w-full h-full object-cover"/>` : `<div class="text-gray-400 text-sm">Kein Bild</div>`}
                        </div>
                        <div class="flex flex-col gap-y-1 text-sm flex-grow overflow-y-auto pr-1">
                            ${categoryHtml}
                        </div>
                    </div>
                `;
            };

            // Function to generate card back HTML for rendering (used by html2canvas)
            // Erzeugt den HTML-Inhalt der Kartenrückseite für den Export.
            const generateCardBackHtml = (cardBack) => {
                let backgroundStyle = '';
                let textContent = cardBack.text || ''; // Set textContent to empty string if cardBack.text is empty

                if (cardBack.type === 'color') {
                    backgroundStyle = `background-color: ${cardBack.color};`;
                } else if (cardBack.type === 'gradient') {
                    backgroundStyle = `background: linear-gradient(to bottom right, ${cardBack.gradientStart}, ${cardBack.gradientEnd});`;
                } else if (cardBack.type === 'image' && cardBack.image) {
                    backgroundStyle = `background-image: url(${cardBack.image}); background-size: cover; background-position: center;`;
                } else if (cardBack.type === 'text') {
                     backgroundStyle = `background-color: #3b82f6;`; // Default blue for text-only
                }


                return `
                    <div class="card-content flex items-center justify-center p-4 text-white text-center font-bold" style="${backgroundStyle} width: 100%; height: 100%; box-sizing: border-box; font-size: 1.875rem;">
                        ${textContent ? `<span class="p-2 bg-black bg-opacity-50 rounded-md">${textContent}</span>` : ''}
                    </div>
                `;
            };

            // Export cards to PDF
            const exportToPdf = async () => {
                if (cards.length === 0) {
                    alert('Bitte erstellen Sie zuerst Karten, bevor Sie exportieren.');
                    return;
                }
                setIsExporting(true);

                const doc = new window.jspdf.jsPDF({
                    orientation: 'portrait',
                    unit: 'mm',
                    format: 'a4'
                });

                const cardWidthMm = 80;
                const cardHeightMm = 106.67; // 3:4 aspect ratio (80 * 4/3)
                const margin = 10; // mm
                const cutMarkLength = 5; // mm

                const cardsPerRow = 2;
                const rowsPerPage = 3;
                const cardsPerPage = cardsPerRow * rowsPerPage; // 6 cards per page

                const colWidth = (doc.internal.pageSize.getWidth() - 2 * margin) / cardsPerRow;
                const rowHeight = (doc.internal.pageSize.getHeight() - 2 * margin) / rowsPerPage;

                // Helper to render HTML content to canvas
                const renderHtmlToCanvas = async (htmlContent, widthPx, heightPx) => {
                    const tempDiv = document.createElement('div');
                    tempDiv.style.width = `${widthPx}px`;
                    tempDiv.style.height = `${heightPx}px`;
                    tempDiv.style.position = 'absolute';
                    tempDiv.style.left = '-9999px'; // Off-screen
                    tempDiv.style.top = '-9999px';
                    tempDiv.innerHTML = htmlContent;
                    document.body.appendChild(tempDiv);

                    const canvas = await html2canvas(tempDiv, {
                        scale: 1, // Use original scale, as we set px dimensions
                        useCORS: true,
                        logging: false
                    });
                    document.body.removeChild(tempDiv);
                    return canvas;
                };

                // Add cut marks around a card
                const addCutMarks = (pdf, x, y, width, height) => {
                    pdf.setDrawColor(150); // Gray color for cut marks
                    pdf.setLineWidth(0.2);

                    // Top-left corner
                    pdf.line(x, y, x + cutMarkLength, y);
                    pdf.line(x, y, x, y + cutMarkLength);
                    // Top-right corner
                    pdf.line(x + width - cutMarkLength, y, x + width, y);
                    pdf.line(x + width, y, x + width, y + cutMarkLength);
                    // Bottom-left corner
                    pdf.line(x, y + height, x + cutMarkLength, y + height);
                    pdf.line(x, y + height - cutMarkLength, x, y + height);
                    // Bottom-right corner
                    pdf.line(x + width - cutMarkLength, y + height, x + width, y + height);
                    pdf.line(x + width, y + height - cutMarkLength, x + width, y + height);
                };

                // Render front sides
                for (let i = 0; i < cards.length; i++) {
                    if (i % cardsPerPage === 0 && i !== 0) {
                        doc.addPage();
                    }

                    const card = cards[i];
                    const cardHtml = generateCardHtml(card, categories);
                    const canvas = await renderHtmlToCanvas(cardHtml, cardWidthMm * 3.779528, cardHeightMm * 3.779528); // Convert mm to px for html2canvas
                    const imgData = canvas.toDataURL('image/jpeg', 0.9);

                    const col = i % cardsPerRow;
                    const row = Math.floor((i % cardsPerPage) / cardsPerRow);
                    const xPos = margin + col * colWidth + (colWidth - cardWidthMm) / 2;
                    const yPos = margin + row * rowHeight + (rowHeight - cardHeightMm) / 2;

                    doc.addImage(imgData, 'JPEG', xPos, yPos, cardWidthMm, cardHeightMm);
                    addCutMarks(doc, xPos, yPos, cardWidthMm, cardHeightMm);
                }

                // Render back sides (on new pages, alternating)
                // Ensure there's a new page if the last front card filled the page
                if (cards.length > 0 && cards.length % cardsPerPage !== 0) {
                     doc.addPage();
                } else if (cards.length === 0) {
                    // No cards to generate backs for
                } else {
                    doc.addPage(); // Add a new page for backs if the last front page was full
                }


                for (let i = 0; i < cards.length; i++) {
                    if (i % cardsPerPage === 0 && i !== 0) {
                        doc.addPage();
                    }

                    const cardBackHtml = generateCardBackHtml(cardBack);
                    const canvas = await renderHtmlToCanvas(cardBackHtml, cardWidthMm * 3.779528, cardHeightMm * 3.779528); // Convert mm to px
                    const imgData = canvas.toDataURL('image/jpeg', 0.9);

                    const col = i % cardsPerRow;
                    const row = Math.floor((i % cardsPerPage) / cardsPerRow);
                    const xPos = margin + col * colWidth + (colWidth - cardWidthMm) / 2;
                    const yPos = margin + row * rowHeight + (rowHeight - cardHeightMm) / 2;

                    doc.addImage(imgData, 'JPEG', xPos, yPos, cardWidthMm, cardHeightMm);
                    addCutMarks(doc, xPos, yPos, cardWidthMm, cardHeightMm);
                }

                doc.save(`${gameTitle || 'Quartett'}_Karten.pdf`);
                setIsExporting(false);
            };

            // Export cards to ZIP
            const exportToZip = async () => {
                if (cards.length === 0) {
                    alert('Bitte erstellen Sie zuerst Karten, bevor Sie exportieren.');
                    return;
                }
                setIsExporting(true);
                const zip = new JSZip();
                const cardImagesFolder = zip.folder("Kartenbilder");

                const cardWidthPx = 600; // Desired pixel width for card images
                const cardHeightPx = 800; // 3:4 aspect ratio

                const renderHtmlToCanvasForZip = async (htmlContent) => {
                    const tempDiv = document.createElement('div');
                    tempDiv.style.width = `${cardWidthPx}px`;
                    tempDiv.style.height = `${cardHeightPx}px`;
                    tempDiv.style.position = 'absolute';
                    tempDiv.style.left = '-9999px'; // Off-screen
                    tempDiv.style.top = '-9999px';
                    tempDiv.innerHTML = htmlContent;
                    document.body.appendChild(tempDiv);

                    const canvas = await html2canvas(tempDiv, {
                        scale: 1, // Use original scale, as we set px dimensions
                        useCORS: true,
                        logging: false
                    });
                    document.body.removeChild(tempDiv);
                    return canvas;
                };

                for (let i = 0; i < cards.length; i++) {
                    const card = cards[i];
                    const cardHtml = generateCardHtml(card, categories);
                    const cardBackHtml = generateCardBackHtml(cardBack);

                    // Render front
                    const frontCanvas = await renderHtmlToCanvasForZip(cardHtml);
                    const frontImgData = frontCanvas.toDataURL('image/jpeg', 0.9).split(',')[1];
                    cardImagesFolder.file(`Karte_${i + 1}_Vorderseite_${card.title || 'unbenannt'}.jpg`, frontImgData, { base64: true });

                    // Render back
                    const backCanvas = await renderHtmlToCanvasForZip(cardBackHtml);
                    const backImgData = backCanvas.toDataURL('image/jpeg', 0.9).split(',')[1];
                    cardImagesFolder.file(`Karte_${i + 1}_Rückseite.jpg`, backImgData, { base64: true });
                }

                zip.generateAsync({ type: "blob" })
                    .then(function (content) {
                        const url = URL.createObjectURL(content);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${gameTitle || 'Quartett'}_Kartenbilder.zip`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        setIsExporting(false);
                    })
                    .catch(e => {
                        console.error("ZIP export error:", e);
                        alert("Fehler beim Exportieren der ZIP-Datei.");
                        setIsExporting(false);
                    });
            };

            return (
                <div className="bg-white p-4 sm:p-6 rounded-xl shadow-md mb-6">
                    <h2 className="text-xl sm:text-2xl font-semibold mb-4 text-gray-800">Export-Optionen</h2>
                    <div className="flex flex-col sm:flex-row gap-4">
                        <button
                            onClick={exportToPdf}
                            disabled={isExporting}
                            className="flex-1 px-6 py-3 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors font-semibold text-lg
                                       shadow-lg hover:shadow-xl transform hover:-translate-y-0.5"
                        >
                            {isExporting ? 'Exportiere PDF...' : 'Als PDF exportieren'}
                        </button>
                        <button
                            onClick={exportToZip}
                            disabled={isExporting}
                            className="flex-1 px-6 py-3 bg-purple-600 text-white rounded-md hover:bg-purple-700 transition-colors font-semibold text-lg
                                       shadow-lg hover:shadow-xl transform hover:-translate-y-0.5"
                        >
                            {isExporting ? 'Exportiere ZIP...' : 'Als ZIP (JPEGs) exportieren'}
                        </button>
                    </div>
                    {isExporting && (
                        <p className="text-center text-gray-600 mt-4">Bitte warten, Export wird vorbereitet...</p>
                    )}
                </div>
            );
        };


        // Main App Component
        // Hauptkomponente der Anwendung. Sie verwaltet den globalen Zustand des gesamten Quartettspiels.
        const App = () => {
            // Zustand für die Spiel-Einstellungen
            const [gameTitle, setGameTitle] = React.useState('');
            const [categories, setCategories] = React.useState([]); // [{ id: 'uuid', name: 'Tore' }]
            const [numCards, setNumCards] = React.useState(0);
            const [cards, setCards] = React.useState([]); // [{ id: 'uuid', title: '', image: '', categoryValues: { 'catId1': 'val1', ... } }]
            const [cardBack, setCardBack] = React.useState({
                type: 'color', // 'color', 'gradient', 'image', 'text'
                color: '#3b82f6', // default blue
                gradientStart: '#3b82f6', // default blue
                gradientEnd: '#1d4ed8', // darker blue
                text: 'Mein Quartett',
                image: null // Base64 string
            });
            // Zustand für die Bearbeitung einer Karte im Modal
            const [editingCardId, setEditingCardId] = React.useState(null);

            // Load from LocalStorage on initial render (Beim ersten Rendern aus LocalStorage laden)
            React.useEffect(() => {
                try {
                    const savedState = localStorage.getItem('quartetGame');
                    if (savedState) {
                        const parsedState = JSON.parse(savedState);
                        setGameTitle(parsedState.gameTitle || '');
                        setCategories(parsedState.categories || []);
                        setNumCards(parsedState.numCards || 0);
                        setCards(parsedState.cards || []);
                        setCardBack(parsedState.cardBack || {
                            type: 'color',
                            color: '#3b82f6',
                            gradientStart: '#3b82f6',
                            gradientEnd: '#1d4ed8',
                            text: 'Mein Quartett',
                            image: null
                        });
                    }
                } catch (error) {
                    console.error("Fehler beim Laden aus LocalStorage:", error);
                }
            }, []);

            // Save to LocalStorage whenever state changes (Bei jeder Zustandsänderung in LocalStorage speichern)
            React.useEffect(() => {
                const stateToSave = {
                    gameTitle,
                    categories,
                    numCards,
                    cards,
                    cardBack
                };
                try {
                    localStorage.setItem('quartetGame', JSON.stringify(stateToSave));
                } catch (error) {
                    console.error("Fehler beim Speichern in LocalStorage:", error);
                }
            }, [gameTitle, categories, numCards, cards, cardBack]);

            // Adjust cards array when numCards changes (Karten-Array anpassen, wenn sich numCards ändert)
            React.useEffect(() => {
                setCards(prevCards => {
                    const newCards = [];
                    for (let i = 0; i < numCards; i++) {
                        if (prevCards[i]) {
                            // Keep existing card if it exists
                            newCards.push(prevCards[i]);
                        } else {
                            // Create new card with default values and category placeholders
                            const newCardId = generateUniqueId();
                            const initialCategoryValues = {};
                            categories.forEach(cat => {
                                initialCategoryValues[cat.id] = '';
                            });
                            newCards.push({
                                id: newCardId,
                                title: `Karte ${i + 1}`,
                                image: null,
                                categoryValues: initialCategoryValues
                            });
                        }
                    }
                    return newCards;
                });
            }, [numCards, categories]); // Re-run if categories change to update new cards

            // Callback to handle category changes from GameSetup
            // Aktualisiert Karten, wenn sich Kategorien ändern (z.B. neue Kategorie hinzugefügt)
            const handleCategoriesChange = React.useCallback((updatedCategories) => {
                setCategories(updatedCategories);
                // Update existing cards to reflect new categories
                setCards(prevCards => prevCards.map(card => {
                    const newCategoryValues = {};
                    updatedCategories.forEach(cat => {
                        newCategoryValues[cat.id] = card.categoryValues[cat.id] || '';
                    });
                    // Remove values for categories that no longer exist
                    const filteredCategoryValues = Object.fromEntries(
                        Object.entries(newCategoryValues).filter(([catId]) =>
                            updatedCategories.some(cat => cat.id === catId)
                        )
                    );
                    return { ...card, categoryValues: filteredCategoryValues };
                }));
            }, []);

            // Save changes to a card and close the editor modal
            const handleSaveCard = (updatedCard) => {
                setCards(prevCards =>
                    prevCards.map(card => (card.id === updatedCard.id ? updatedCard : card))
                );
                setEditingCardId(null); // Close modal
            };

            // Cancel editing a card and close the editor modal
            const handleCancelEdit = () => {
                setEditingCardId(null); // Close modal
            };

            // Find the card currently being edited
            const editingCard = cards.find(card => card.id === editingCardId);

            return (
                <div className="min-h-screen bg-gray-100 p-4 sm:p-8">
                    <h1 className="text-3xl sm:text-4xl font-extrabold text-center text-gray-900 mb-8">
                        Quartett-Karten-Ersteller
                    </h1>

                    <div className="max-w-4xl mx-auto">
                        {/* Game Setup Component */}
                        <GameSetup
                            gameTitle={gameTitle}
                            setGameTitle={setGameTitle}
                            categories={categories}
                            setCategories={setCategories}
                            numCards={numCards}
                            setNumCards={setNumCards}
                            cardBack={cardBack}
                            setCardBack={setCardBack}
                            onCategoriesChange={handleCategoriesChange}
                        />

                        {/* Card Preview and Editing Section */}
                        <div className="bg-white p-4 sm:p-6 rounded-xl shadow-md mb-6">
                            <h2 className="text-xl sm:text-2xl font-semibold mb-4 text-gray-800">Karten-Vorschau & Bearbeitung</h2>
                            {numCards === 0 ? (
                                <p className="text-gray-600 text-center">Bitte legen Sie zuerst die Anzahl der Karten fest.</p>
                            ) : (
                                <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4">
                                    {cards.map(card => (
                                        <CardPreview
                                            key={card.id}
                                            card={card}
                                            categories={categories}
                                            onClick={setEditingCardId}
                                        />
                                    ))}
                                </div>
                            )}
                        </div>

                        {/* Export Buttons Component */}
                        <ExportButtons
                            gameTitle={gameTitle}
                            cards={cards}
                            categories={categories}
                            cardBack={cardBack}
                        />
                    </div>

                    {/* Card Editor Modal (conditionally rendered) */}
                    {editingCardId && (
                        <CardEditor
                            card={editingCard}
                            categories={categories}
                            onSave={handleSaveCard}
                            onCancel={handleCancelEdit}
                            cardBack={cardBack} // Pass cardBack for live preview
                        />
                    )}
                </div>
            );
        };

        // Render the main App component into the root div
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>